! PROGRAMA PARA RECOPILAR EL CONTENIDO DE LA MATRIZ DE ADYANCECIA DE TAL FORMA DE QUE NO GUARDEMOS LOS 0 QUE ÉSTA CONTIENE FORMADA POR 1014 CONNECTOMAS, A PARTIR DE LA EDGELIST DE LAS DIFERENTES LAYERS DE UN CEREBRO CONCRETO del proyecto HCP
       PROGRAM EDGELISTHCP
       IMPLICIT NONE
       INTEGER*8 I,J,N,NODE,SUM,K,EDGES,LINE,IOSTATUS
       INTEGER, ALLOCATABLE :: DEGREE(:), NEIGHBOURS(:)
       INTEGER, POINTER :: HEAD(:), COUNT(:)
       
! -----------------------------------------------LAYER 0--------------------------------------------------------
! INICIAMOS LAS VARIABLES
       NODE = 1014
       EDGES = 0
       SUM = 0

! LA DIMENSION DEL VECTOR QUE CONTIENE EL GRADO DE CADA NODO ES NÚMERO DE NODOS DE LA RED, EN NUESTRO CASO 1014 (PARA LA LAYER L = 0)
       ALLOCATE(DEGREE(NODE))
       DEGREE = 0
    
! ABRIMOS EL ARCHIVO DE UL/HCP DATASET
       OPEN(19, FILE = "HCP_nobrainstem_22_layer_0_edgelist.txt")

! CALCULAMOS LAS FILAS DE LA EDGE LIST (NUMERO DE CONNEXIONES)
       DO
        READ(19, *, IOSTAT = IOSTATUS) LINE ! LEEMOS LINEA DEL ARCHIVO
        IF (IOSTATUS /= 0) EXIT !SI LLEGA AL FINAL DEL ARCHIVO QUE SALGA
        EDGES = EDGES + 1
       ENDDO

! EL VALOR DE EDGES SERA MAYOR AL NUMERO DE CONNEXIONES QUE HAY PERO AL AÑADIR UNA VARIABLE DE CONTROL NO HAY PROBLEMA CON ESO
       CLOSE(19)
       OPEN(30, FILE = "HCP_nobrainstem_22_layer_0_edgelist.txt")
        
! CALCULAMOS EL VECTOR QUE CONTIENE LOS GRADOS
       DO N = 1, EDGES
        READ(30, *, IOSTAT = IOSTATUS) I,J
        IF (IOSTATUS /= 0) THEN
            WRITE(*,*) 'ERROR AL LEER LA EDGE LIST EN LA FILA ', N
            WRITE(*,*) I, J
            EXIT
        ENDIF
        DEGREE(I+1) = DEGREE(I+1) + 1 !SUMAMOS 1 YA QUE EL PRIMER NODO ES 0
        DEGREE(J+1) = DEGREE(J+1) + 1
       ENDDO
       
       CLOSE(30)

       OPEN(48, FILE = "degrees0.txt")
!ESCRIBIMOS LOS GRADOS EN UN ARCHIVO DE TEXTO
       DO N = 1, NODE
        SUM = SUM + DEGREE(N)
        WRITE(48,'(I0,3X,I0)') (N-1), DEGREE(N)
       ENDDO

       CLOSE(48)

       WRITE(*,*) 'LAYER 0'
       WRITE(*,*) 'Suma de los degrees: ', SUM
       WRITE(*,*)'<k> = ',DBLE(SUM)/NODE

!--------------------------------------------------------------------------------------
! VECTOR QUE CONTIENE LOS VECINOS DE CADA NODO ORDENADAMENTE(V), DESDE EL NODO 0 AL 1013. JUNTO CON EL DEGREE DE CADA UNO SERIA UNA ALTERNATIVA A ALMACENAR LA EDGELIST, CONTENIENDO TODA LA INFORMACION DE LA MATRIZ DE ADYACENCIA SIN GUARDAR LOS 0

! DEFINIMOS LA DIMENSIONALIDAD DEL VECTOR Y LOS PUNTEROS
       ALLOCATE(NEIGHBOURS(SUM))
       ALLOCATE(HEAD(NODE+1))
       ALLOCATE(COUNT(NODE+1))
     
       NEIGHBOURS = 0
    
! RELLENAMOS EL PUNTERO HEAD() EN EL CUAL CADA POSICION SERA EL GRADO POR EL QUE EMPEZARÁN A CONTAR LOS VECINOS DE CADA NODO
! INICIALIZAMOS EL PUNTERO COUNT(), SERVIRÁ PARA CONTROLAR EN QUE POSICION DEL VECTOR V COLOCAR AL VECINO CORRESPONDIENTE.
       HEAD(1) = 1
       COUNT(1) = 1
        
       DO I = 2, NODE+1
        HEAD(I) = HEAD(I-1) + DEGREE(I-1)
        COUNT(I) = 1
       ENDDO

       OPEN(81, FILE = "HCP_nobrainstem_22_layer_0_edgelist.txt")

!CALCULAMOS EL VECTOR V RELLENANDO A MEDIDA QUE ENCONTRAMOS LOS VECINOS, SUMAMOS 1 YA QUE EL PRIMER NODO ES EL 0 Y LA POSICIÓN 0 NO EXISTE
       DO K = 1,EDGES
        READ(81,*,IOSTAT = IOSTATUS) I,J
        IF (IOSTATUS /= 0) EXIT
        NEIGHBOURS(HEAD(I+1)+COUNT(I+1)-1) = J
        COUNT(I+1) = COUNT(I+1) + 1
        NEIGHBOURS(HEAD(J+1)+COUNT(J+1)-1) = I
        COUNT(J+1) = COUNT(J+1) + 1
       ENDDO
       CLOSE(81)

       OPEN(101, FILE = 'neighbours0.txt')
       
! ESCRIBIMOS EL VECTOR V EN UN ARCHIVO
       DO K = 1,SUM
        WRITE(101,'(I0)') NEIGHBOURS(K)
       ENDDO
       CLOSE(101)

       END PROGRAM EDGELISTHCP

    

